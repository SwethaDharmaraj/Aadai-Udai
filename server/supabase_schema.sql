-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- 1. PROFILES TABLE
create table public.profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  name text,
  phone text,
  role text default 'user',
  addresses jsonb default '[]'::jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for Profiles
alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- 2. PRODUCTS TABLE
create table public.products (
  id bigint generated by default as identity primary key,
  name text not null,
  description text,
  category text,
  sub_category text,
  price numeric not null,
  discounted_price numeric,
  sizes text[],
  stock integer default 0,
  variant_stock jsonb default '{}'::jsonb, -- Stores stock levels for each size variant
  featured boolean default false,
  images text[],
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS for Products
alter table public.products enable row level security;

create policy "Products are viewable by everyone."
  on products for select
  using ( true );

create policy "Admins can insert products."
  on products for insert
  with check ( 
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Admins can update products."
  on products for update
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

create policy "Admins can delete products."
  on products for delete
  using (
    exists (
      select 1 from profiles
      where id = auth.uid() and role = 'admin'
    )
  );

-- Helper function for Admin check (Optional, or just use Service Role which bypasses everything)
-- We rely on Service Role in backend, so policies are secondary for Admin API calls.
-- But for protection, we keep them.

-- 3. ORDERS TABLE
create table public.orders (
  id bigint generated by default as identity primary key,
  order_id text unique, -- Readable ID like "ORD-123"
  user_id uuid references public.profiles(id),
  total_amount numeric,
  status text default 'pending', -- pending, confirmed, shipped, delivered, cancelled
  shipping_address jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.orders enable row level security;

create policy "Users can view own orders."
  on orders for select
  using ( auth.uid() = user_id );

create policy "Admins can view all orders."
  on orders for select
  using ( 
    exists ( select 1 from profiles where id = auth.uid() and role = 'admin' )
  );

-- 4. ORDER ITEMS (optional if embedded, but good for reporting)
create table public.order_items (
  id bigint generated by default as identity primary key,
  order_id bigint references public.orders(id) on delete cascade,
  product_id bigint references public.products(id),
  quantity integer,
  price numeric, -- Price at time of purchase
  size text
);

alter table public.order_items enable row level security;

create policy "Viewable by order owner"
  on order_items for select
  using ( 
    exists ( select 1 from orders where id = order_items.order_id and user_id = auth.uid() ) 
  );

-- 5. REVIEWS
create table public.reviews (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id),
  product_id bigint references public.products(id),
  rating integer check (rating >= 1 and rating <= 5),
  comment text,
  is_approved boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.reviews enable row level security;

create policy "Reviews viewable by everyone"
  on reviews for select
  using ( true );

create policy "Users can create reviews"
  on reviews for insert
  with check ( auth.uid() = user_id );

-- 6. TRANSACTIONS
create table public.transactions (
  id bigint generated by default as identity primary key,
  user_id uuid references public.profiles(id),
  order_id bigint references public.orders(id),
  amount numeric,
  payment_method text, -- 'Razorpay', 'Demo', 'UPI', 'Card', 'COD'
  payment_status text default 'pending', -- 'pending', 'success', 'failed'
  transaction_id text, -- Our internal tracking ID
  razorpay_order_id text,
  razorpay_payment_id text,
  razorpay_signature text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.transactions enable row level security;

create policy "Users view own transactions"
  on transactions for select
  using ( auth.uid() = user_id );

-- STORAGE BUCKETS (Already created via script, but for reference)
insert into storage.buckets (id, name, public)
values ('products', 'products', true)
on conflict (id) do nothing;

create policy "Public Access"
  on storage.objects for select
  using ( bucket_id = 'products' );

create policy "Admin Upload"
  on storage.objects for insert
  with check ( bucket_id = 'products' ); -- Admin check handled by Service Role

-- 7. CART ITEMS
create table public.cart_items (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null, -- Reference auth.users directly to avoid Profile dependency issues
  product_id bigint references public.products(id),
  quantity integer default 1,
  size text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table public.cart_items enable row level security;

create policy "Users can view own cart."
  on cart_items for select
  using ( auth.uid() = user_id );

create policy "Users can insert into own cart."
  on cart_items for insert
  with check ( auth.uid() = user_id );

create policy "Users can update own cart."
  on cart_items for update
  using ( auth.uid() = user_id );

create policy "Users can delete from own cart."
  on cart_items for delete
  using ( auth.uid() = user_id );

